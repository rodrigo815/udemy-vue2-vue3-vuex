/**
 *  Copyright 2021 Thorsten Luenborg 
 *  @license MIT
 */
import{inject as t,provide as e,defineComponent as o,onMounted as n,onUpdated as r,onBeforeUnmount as a,watch as l,computed as s,h as u,reactive as p,readonly as c,createApp as d,getCurrentInstance as i}from"vue";const f=Symbol("wormhole");function m(){const e=t(f);if(!e)throw new Error("\n    [portal-vue]: Necessary Injection not found. Make sur you installed the plugin properly.");return e}function v(t){e(f,t)}const g="undefined"!=typeof window;var y=o({compatConfig:{MODE:3},name:"portal",props:{disabled:{type:Boolean},name:{type:[String,Symbol],default:()=>Symbol()},order:{type:Number},slotProps:{type:Object,default:()=>({})},to:{type:String,default:()=>String(Math.round(1e7*Math.random()))}},setup:(t,{slots:e})=>(function(t,e){const o=m();function s(){if(!g)return;const{to:n,name:r,order:a}=t;e.default?o.open({to:n,from:r,order:a,content:e.default}):u()}function u(e){o.close({to:null!=e?e:t.to,from:t.name})}n((()=>{t.disabled||s()})),r((()=>{t.disabled?u():s()})),a((()=>{u()})),l((()=>t.to),((e,o)=>{t.disabled||(o&&o!==e&&u(o),s())}))}(t,e),()=>t.disabled&&e.default?e.default(t.slotProps):null)});const h=(t,{slots:e})=>{var o;return null===(o=e.default)||void 0===o?void 0:o.call(e)};var b=o({compatConfig:{MODE:3},name:"portalTarget",props:{multiple:{type:Boolean,default:!1},name:{type:String,required:!0},slotProps:{type:Object,default:()=>({})}},emits:["change"],setup(t,{emit:e,slots:o}){const n=m(),r=s((()=>{const e=n.getContentForTarget(t.name,t.multiple),r=o.wrapper,a=e.map((e=>e.content(t.slotProps))),l=r?a.flatMap((t=>t.length?r(t):[])):a.flat(1);return{vnodes:l,vnodesFn:()=>l}}));return l(r,(({vnodes:o})=>{const r=o.length>0,a=n.transports.get(t.name),l=a?[...a.keys()]:[];e("change",{hasContent:r,sources:l})}),{flush:"post"}),()=>{var t;return!!r.value.vnodes.length?[u("div",{style:"display: none",key:"__portal-vue-hacky-scoped-slot-repair__"}),u(h,r.value.vnodesFn)]:null===(t=o.default)||void 0===t?void 0:t.call(o)}}});function w(t=!0){const e=p(new Map);const o={open:function(t){if(!g)return;const{to:o,from:n,content:r,order:a=1/0}=t;if(!o||!n||!r)return;e.has(o)||e.set(o,new Map);const l={to:o,from:n,content:r,order:a};e.get(o).set(n,l)},close:function(t){const{to:o,from:n}=t;if(!o||!n)return;const r=e.get(o);r&&(r.delete(n),r.size||e.delete(o))},transports:e,getContentForTarget:function(t,o){const n=e.get(t);if(!n)return[];const r=Array.from((null==n?void 0:n.values())||[]);return o?(a=(t,e)=>t.order-e.order,r.map(((t,e)=>[e,t])).sort((function(t,e){return a(t[1],e[1])||t[0]-e[0]})).map((t=>t[1]))):[r.pop()];var a}};return t?c(o):o}const M=w();function S(t,e){var o;const r=d({render:()=>u(b,t)});if(!t.multiple){const t=null!==(o=i().provides)&&void 0!==o?o:{};r._context.provides=Object.create(t)}n((()=>{r.mount(e)})),a((()=>{r.unmount()}))}function N(t,e={}){var o;!1!==e.portalName&&t.component(e.portalName||"Portal",y),!1!==e.portalTargetName&&t.component(e.portalTargetName||"PortalTarget",b);const n=null!==(o=e.wormhole)&&void 0!==o?o:M;t.provide(f,n)}const P=M,T="3.0.0-beta.0";export default N;export{y as Portal,b as PortalTarget,P as Wormhole,w as createWormhole,N as install,S as mountPortalTarget,v as provideWormhole,m as useWormhole,T as version};
